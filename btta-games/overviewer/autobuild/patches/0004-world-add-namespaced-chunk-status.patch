From 4e909e591874ca689a44b26f83144bd9703208dd Mon Sep 17 00:00:00 2001
From: Tianhao Chai <cth451@gmail.com>
Date: Thu, 29 May 2025 02:52:29 -0400
Subject: [PATCH] world: add namespaced chunk status

---
 overviewer_core/world.py | 35 +++++++++++++++++++----------------
 1 file changed, 19 insertions(+), 16 deletions(-)

diff --git a/overviewer_core/world.py b/overviewer_core/world.py
index 0fd3f79..4d633b4 100644
--- a/overviewer_core/world.py
+++ b/overviewer_core/world.py
@@ -14,19 +14,16 @@
 #    with the Overviewer.  If not, see <http://www.gnu.org/licenses/>.
 
 import functools
+import logging
 import os
 import os.path
-import logging
-import time
-import random
 import re
-import locale
+import time
 
 import numpy
-import math
 
-from . import nbt
 from . import cache
+from . import nbt
 from .biome import reshape_biome_data
 
 """
@@ -202,12 +199,12 @@ class World(object):
             spawnY = -63
         if spawnY > 319:
             spawnY = 319
-            
+
         ## The chunk that holds the spawn location
         chunkX = spawnX//16
         chunkY = spawnY//16
         chunkZ = spawnZ//16
-        
+
         ## The block for spawn *within* the chunk
         inChunkX = spawnX % 16
         inChunkZ = spawnZ % 16
@@ -221,9 +218,9 @@ class World(object):
             chunk = regionset.get_chunk(chunkX, chunkZ)
         except ChunkDoesntExist:
             return (spawnX, spawnY, spawnZ)
-        
+
         ## Check for first air block (0) above spawn
-        
+
         # Get only the spawn section and the ones above, ordered from low to high
         spawnChunkSections = sorted(chunk['Sections'], key=lambda sec: sec['Y'])[chunkY:]
         for section in spawnChunkSections:
@@ -1164,7 +1161,7 @@ class RegionSet(object):
             if palette_entry['Properties']['half'] == 'upper':
                 data |= 0x08
         elif key in wood_slabs + stone_slabs + prismarine_slabs + copper_slabs:
-        # handle double slabs 
+        # handle double slabs
             if palette_entry['Properties']['type'] == 'top':
                 data |= 0x08
             elif palette_entry['Properties']['type'] == 'double':
@@ -1490,7 +1487,7 @@ class RegionSet(object):
             result[1::2] = ( b[2::3]         << 4) | ((b[1::3] & 0xf0) >> 4)
 
         return result
-    
+
     def _packed_longarray_to_shorts_v116(self, long_array, n, num_palette):
         bits_per_value = max(4, (len(long_array) * 64) // n)
 
@@ -1502,7 +1499,7 @@ class RegionSet(object):
         for i in range(shorts_per_long):
             j = (n + shorts_per_long - 1 - i) // shorts_per_long
             result[i::shorts_per_long] = (b[:j] >> (bits_per_value * i)) & mask
-        
+
         return result
 
     def _get_blockdata_v118(self, section, unrecognized_block_types, longarray_unpacker):
@@ -1688,9 +1685,15 @@ class RegionSet(object):
         # Empty is self-explanatory, and liquid_carved and carved seem to correspond
         # to SkyLight not being calculated, which results in mostly-black chunks,
         # so we'll just pretend they aren't there.
-        if chunk_data.get("Status", "") not in ("full", "postprocessed", "fullchunk",
-                                                "mobs_spawned", "spawn", ""):
-            raise ChunkDoesntExist("Chunk %s,%s doesn't exist" % (x,z))
+        if chunk_data.get("Status", "") not in {"full",
+                                                "postprocessed",
+                                                "fullchunk",
+                                                "mobs_spawned",
+                                                "spawn",
+                                                "minecraft:full",
+                                                "minecraft:spawn",
+                                                ""}:
+            raise ChunkDoesntExist("Chunk %s,%s doesn't exist" % (x, z))
 
         # Turn the Biomes array into a 16x16 numpy array
         if 'Biomes' in chunk_data and len(chunk_data['Biomes']) > 0:
-- 
2.49.0

